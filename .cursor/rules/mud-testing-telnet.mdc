---
description: when manually testing something
alwaysApply: false
---
When testing MUD commands and functionality, use the telnet tool to connect to the live game server and verify implementations work correctly.

## Setup Process

1. **Set LLM Identity** (required before connecting):
```
mcp_telnet_set_llm_identity:
- name: "Claude"
- provider: "Anthropic"
- version: "3.5 Sonnet"
- capabilities: ["code_analysis", "game_testing", "command_execution"]
```

2. **Connect to MUD Server**:
```
mcp_telnet_connect_telnet:
- host: "localhost"
- port: 4000
```

3. **Login as Owner**:
```
connect owner 123
```

## Testing Commands

### CRITICAL: Reload Server After Code Changes
**ALWAYS run `reload` command in-game after making code changes to ensure new code is loaded:**
```
reload
```
The server needs to be reloaded to pick up any Python code modifications.

### Available Commands at Login Screen
- `help` - shows available commands
- `connect <username> <password>` - login format
- `create <username> <password>` - create new account
- `look` - re-show connection screen

### In-Game Testing Process
1. **Reload server**: `reload` after any code changes
2. **Check environment**: `look` to see current room and available objects
3. **Check inventory**: `inventory` to see what items you have
4. **Test command functionality**: Execute the command being tested
5. **Debug with examine**: `examine` or `ex` for detailed object inspection
6. **Test error conditions**: Try invalid arguments, missing objects, wrong types
7. **Verify state changes**: Check inventory/environment after commands

### Debug Commands
- `examine <object>` or `ex <object>` - Get detailed object information including:
  - Object ID and typeclass
  - Persistent attributes with categories and types
  - Contents and location
  - Locks and permissions
- `ex #<id>` - Examine object by specific ID number

### Common Test Cases for Commands
- **No arguments**: Test command with no parameters
- **Invalid object**: Test with non-existent object names
- **Wrong object type**: Test with objects that don't support the action
- **State validation**: Test with objects in invalid states (empty, full, etc.)
- **Multiple uses**: Test repeated usage to verify state tracking

## Example Testing Session
```
reload                 # ALWAYS reload after code changes
look                   # Check environment
inventory             # Check starting items
ex cantil             # Debug container details
ex #55                # Debug specific object by ID
drink cantil          # Test successful usage
ex cantil             # Verify state changes
drink cantil          # Test multiple uses
drink banana          # Test non-existent item
drink apple           # Test non-liquid item
drink                 # Test no arguments
drink cantil          # Test empty container
```

## Telnet Tool Commands
- `mcp_telnet_send_command` - Send commands to the MUD
- `mcp_telnet_get_buffer` - Get current response buffer
- `mcp_telnet_disconnect_telnet` - Disconnect from server
- `mcp_telnet_connection_status` - Check connection status

## What to Verify
- ✅ Command executes without errors
- ✅ Error messages match expected patterns
- ✅ Object display names appear correctly
- ✅ State changes persist correctly
- ✅ Edge cases handled gracefully

## Testing Limitations
- **Multi-character testing**: Avoid testing how other characters see messages since this requires multiple simultaneous connections
- **Broadcast message testing**: Focus on testing that commands execute successfully rather than verifying room message reception
- **MsgObj sound effects**: Cannot easily test auditory components without multiple players
- **Single-connection focus**: Test from one character's perspective only

## Benefits of Live Testing
- Verifies DisplayNameWrapper works correctly
- Tests actual game object interaction
- Validates error handling in real environment
- Ensures command integration with live game state
- Confirms state persistence and object manipulation
- Tests weight system integration and container mechanics

## Testing Focus
- **Single-character perspective**: Test command execution, error handling, and state changes
- **Object manipulation**: Verify items move correctly, containers work, attributes persist
- **System integration**: Ensure new architecture works with existing game systems
- **Error validation**: Test all error conditions thoroughly

Always test commands in the live environment after implementation to catch issues that unit tests might miss, but focus on single-character testing scenarios.